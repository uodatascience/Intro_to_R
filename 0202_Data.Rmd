---
title: "2.2 - Data Wrangling"
author: "Jonny Saunders"
date: "10/2/2017"
output: 
  md_document:
    preserve_yaml: true
    toc: true
    toc_depth: 2
order: 3
---
# Loading data

## One day we will have a summary table here

Most of the time we have a datafile (either on our hard drive or on the internet) that we want to work with in R. To do that, we can use a function to read the data into R. For instance, the **`read.table()`** is a flexible function for reading in data in various formats. 

## .csv files
In order to use **`read.table()`**, you will typically need to specify some of the arguments, such as the argument **`sep = `**, which is where you specify the thing that seperates values in your data file.   

For example, if you are working with a data file in the comma seperated values (csv) format, you would need to specify that commas are the seperator with **`sep = ","`**. 

### Defaults 
Thankfully, other people have done this for us, and have created functions that have the proper defaults to work with common formats like csv fles. For csv files, To see the defaults, simply check the documentation with e.g.  **`?read.table`**  

**`read.csv()`** is basically a version of **`read.table()`** with the defaults set up to work well with csv files. These defaults include setting **","** as the seperator, and setting **`header = TRUE`**, which means that R will read in the first row in the csv file as being a header row, and treat that row as the row of column names. These defaults can be changed though, so if you had a file with no header, you would indicate that with **`header = FALSE`**, like so  

`read.csv(file_path/file_name.csv, header = FALSE)` 

where file_path is the full path to the file, and file_name is the name of the data file. Take a look at the documentation for `read.csv()` with `?read.csv()` to see the different arguments and defaults.


### A brief interlude into formats for data in R
There are lots of options for reading data into R, even for a single format.  

For example, we could instead use **`read_csv()`** from the **`readr`** package. The main difference between **`read.csv()`** and **`read_csv()`** is that they load the data into different formats in R. **`read.csv()`** will read your data in as a **`data.frame`**, which is a common format of data in R.  

**`read_csv()`** will read your data in as a **`tibble`**, which is the data format associated with the tidyverse. There are a couple of differences between these formats. They have different printing defaults, there are differences in subsetting, and differences in recycling. Check out the documentation by running the code **`vignette("tibble")`** or by checking out the chapter on tibbles in the R for Data Science Book <http://r4ds.had.co.nz/tibbles.html>. 

Outside of these differences, they are mostly interchangeable (for most purposes), but occassionally a function will only work properly with one or the other. For example, the **`reshape()`** function only works properly with *data.frames* (unless that has changed in an update).  

### Format issues?
In some rare cases, you may be getting an error due to differences between how your data is formatted in R and what format the function you're attempting to use works with.  

This will sometimes be spelled out in the documentation (e.g., **`reshape`** says it takes data frames as the first argument), but its not always clear; sometimes, you just need to test it out. If you do need to go between different formats, that is easy to do in R with a couple of functions. **`as.data.frame()`** will turn an object that can be a dataframe into a dataframe. **`as_tibble`** will turn an object that can be a tibble into a tibble. 

## .sav files

R can also work with datafiles that are formatted for SPSS, which have the extension '.sav'.  

Like csv's, there are a few options. The one that seems to work the best is **`read_spss()`** from the haven package (also a part of the tidyverse). There is also a function called **`read.spss()`** from the **`foreign`** package, but it is no longer being maintained and may stop working; it also had some frustrating qualities, so probably best to stick to **`read_spss()`**. It's worth noting that **`read_spss()`** will format your data as a **`tibble`**. If you don't want it as a **`tibble`**, you can always use the **`as.data.frame()`** function to turn it into a generic **`data.frame`**.

## `rio` for general import

Another function worth knowing about for reading in data is the **`import()`** function from the **`rio`** package. The nice thing about **`import()`** is that it works with lots of different types of datafiles, and very little has to be changed for each type of datafile. For example, if our data (let's say its name is 'df') were a .sav file, we would read it in with the following command:  

`import(df.sav)`

If it were instead a csv, we would use the following command:  

`import(df.csv)`

Note that virtually nothing changed, just the file extension (which is part of the name of the file). **`import()`** is able to figure out the format of the file based on that extension.

**Remember to assign your data to a variable in the environment!**

A pretty common and frustrating mistake people make when starting with R is not saving their data file as an object. For example, if we were loading in our datafile called 'df', we may want to run some code like this:

`import(df.csv)`

However, this is telling R to just read the data. If you run code like that, it will simply read the data, and print out the data (or some subset of it) into the console. Then, when you go to work with the data, it won't be in your global environment. That's because you didn't save it as an object. You would do that the same way you save anything as an object, with the assignment operator: `<-`. So instead of the above, you'd instead want to run something like the following:

`df <- import(df.csv)`

Now R has read our data and stored it as an object called `df`, that we can start running our models on.

# Saving data

Most of the above functions have complementary `write` functions, for example `write.csv` or `haven::write_sav`. There are two other common ways you may want to save your data

## .RData files

Because all objects in R descend from a precious few C structures, they can all be easily **serialized**, or converted into a string of bits that can be written to disk (not always true in other languages, like Python). These files typically can't be read by anything but R (except if that thing is another programming language where someone has written a specific routine to do so!), so if your mom tries to look at your cool data in openoffice they'll be out of luck.

Saving (and loading) .RData files works with the ... `save` and ... `load` functions
```{r}
cant_forget <- c("you have to stop wiping your nose with just whatever is close at hand",
                 "see you did it just now that was mine")
save(cant_forget, file="cant_forget.RData")

# Now delete the object so we know our load is real
rm(cant_forget)

# here we load to the .GlobalEnv, don't worry we'll cover environments later
load("cant_forget.RData")
cant_forget
```

Note: as is true of all files, the extension (ending it with 'RData') doesn't effect the way that a file is saved or represented on the disk, it just serves to tell the operating system which programs can open it, and to tell other programs how they should open it. You could just as easily save your object like

```{r}
save(cant_forget, file="cant_forget.butiwantto")
```

There is one special .RData file, and that's the file that's just called ".RData" in your user directory (for osx `/Users/Username` -- probably hidden by default). R automatically loads this file every time it opens -- this is the file that is made whenever you accept RStudio's frequent offers to save your workspace image.

`save` is also capable of using a few common compression algorithms. This is most useful for large objects that have many repeated values -- common with "long" format data.

```{r}
save(cant_forget, file="cant_forget.RData",
     compress=TRUE, # or "gzip", "bzip2", "xz"
     compression_level=6) # more is smaller, but slower
```

If you're curious, check out the `saveRDS` function - it's designed to save single objects (rather than `save`, which can save arbitrary numbers of objects by keeping them in an environment). Since `save` saves the object and its environment, when it is loaded it will have the same name -- this can be troublesome when you have already used that name, or when you forget what the name is. Loading objects (`readRDS`) saved by `saveRDS` works like other loading functions, so you can assign the loaded object to whatver name you'd like.

```{r}
saveRDS(cant_forget, file="cant_forget.rds")

# We can rewrite our fate.
sad_news <- readRDS("cant_forget.rds")
```

## `sink`

Perhaps common is an overstatement. Consider these the option of last resort when all you want to do is put what you see in this window in some other window and ya don't care how ya do it.

Any output that would go to the console (specifically to `stdout` - try `?stdout` - so it's a bit tricky to open a sink in a code chunk) can be diverted to a file by using the `sink` function. You must call `sink` with a filename to start diverting data, and then call `sink` again to stop. 

```{r}
# Open the sink
sink("save-everything-here.txt")

life_story <- c("what we need at the store 2day guys", "it's always just apples and bananas", "we have severe vitamin deficiencies")
life_story

# turn off the sink
sink()

# now see what's in our file
readLines("save-everything-here.txt")
```

`sink` doesn't work with graphical output, to do that we have to use a function that dumps to a graphics driver, which then saves it as a file. We can see our current graphics device by getting that option...

```{r}
getOption("device")
```

The devices available in the base package are:

* `pdf()`
* `postscript()`
* `xfig()`
* `bitmap()`
* `pictex()`

For example
```{r}
# make n save a cool plot to show your friends
pdf("put-plots-here.pdf")
plot(seq(1,5))
dev.off()

# open the pdf however yer system wants to
abs_path <- file.path(getwd(), "put-plots-here.pdf")
system2('open', args=abs_path, wait=FALSE)
```

Notice how we have to use `dev.off()` rather than calling `pdf()` again as would be expected from `sink`

# Indexing

Or, how to get specific pieces of stuff.

We've already seen a bunch of basic indexing

```{r}
# try ?seq
x <- seq(5, 25, 5)
x

y <- array(1:24, dim=c(3,8))
y

z <- list("scores"=c(1,2,3,4,5), 
          "numbers"=c(6,7,8,9,10))

# good ole positional indexing
x[3]

# indexing with a vector to select multiple positions
x[c(3,5)]

# higher dimensional objects have more dimensions to index
y[1,5]

# both together
y[3, c(3,4,7)]

# leaving a position blank selects all of its indices
y[2,]

# with names
names(x) <- c("adam", "steve", "harry", "ted", "watsom")
x["harry"]
z["numbers"]

# Using double brackets to return a vector instead of a list
z[["numbers"]]

# and the equivalent dollar sign
z$scores
```

Negative values deselect

```{r}
x[-3]

# useful to select starting from the end
-(1:3) # quick way to construct sequences of negative numbers
x[-(1:3)] # get the last two
```

We have also seen chained indexing, think of it like indexing the product of each successive indexing operation

```{r}
x[c(1,3,5)][1]

z[["numbers"]][4]

# one reason why it's important what class is returned from your indexing operation
# aka knowing why we use double brackets
z["numbers"][4]
```

dplyr has a `select` function and a collection of tools ("select helpers") to make selecting variables by name a bit more flexible:

* `starts_with()`
* `ends_with()`
* `contains()`
* `matches()` - variables that match a regular expression
* `num_range()` - eg `num_range("x",1:5)` to select `x1, x2, ...`
* `one_of()` - find variables in a list, eg. `one_of(c("calcium", "potassium", "magnesium"))`
* `everything()` - all variables, don't know why you'd use this.

A few examples...
```{r}
library(dplyr)

df <- ggplot2::diamonds
names(df)

head(select(df, starts_with("c")))

head(select(df, one_of(c("color", "hue", "luminance", "clarity"))))
```

## Logical indexing

In addition to specifying what we want by position, we can specify what we want by using a vector of booleans (`TRUE`, `FALSE`) the same length as the object

```{r}
x[3]

x[c(FALSE, FALSE, TRUE, FALSE, FALSE)]
```

This is useful when combined with logical statements (see `?base::Logic`) and comparisons (see `?Comparison`). One makes logical statements or comparisons with these operators:

| Operator | Use |
| ------- | ------------- |
| `!x` | not x |
| `x & y`, `x && y` | x and y (vectorized, single comparison) |
| `x | y`, `x || y` | x or y (vectorized, single comparison) |
| `xor(x, y)` | exclusive or (x or y but not both) |
| x < y | x less than y |
| x <= y | x less than or equal to y | 
| x > y | x greater than y | 
| x >= y | x greater than or equal to y | 
| x == y | x is equal to y |
| x != y | x is not equal to y |





* Indexing  (Jonny)
    * stacking indexing [][][]
    * dplyr::select and variations like contains, one_of
    * sampling
    * logical indexing & booleans (incl. & vs &&) & converting w/ which
    * set operations
    * subsetting with assignment (x[i] <- 1)
    * creating with subsetting (match, using one vector to pull rows from a df, doing a gradebook w/ commnets), and destroying (unique, dplyr::distinct)
    
    
    
  

# Manupulating Data

Now that you have your data in R, and have maybe subsetted it in some manner, you may want to manipulate the data. In this section, we'll cover some ways that you might want to manipulate data, including manipulating the format of the data and creating new variables (both from combining/splitting existing variables, and creating new ones if you need to).

## Wide vs. Long Data
Let's start by talking about one of the more common data format issues, which is whether data are structured in a *long* or *wide* format. These, like basically all things, exist on a continuum (data is almost always somewhere in between the extremes of long and wide). So, it's probably helpful to start with an example. 

One common design that leads to data easily represented as wide or long is longitudinal data. Let's say we administer the Big Five Inventory - 2 (BFI-2; Soto & John, 2016) to a sample of incoming freshman annually for 4 years. To keep things simple, let's say we only have that data (nothing else was administered). In this case, you may have a dataset that looks like this:
```{r long v wide data Longitudinal Big 5 example, echo = FALSE}
library(tidyverse)
sample_b5_data_wide <- as_tibble(
  cbind(
    pid = seq(1:100),
    agreeableness_t1 = rnorm(100, 3, 1),
    conscientiousness_t1 = rnorm(100, 3, 1),
    neuroticism_t1 = rnorm(100, 3, 1),
    extraversion_t1 = rnorm(100, 3, 1),
    openness_t1 = rnorm(100, 3, 1)))

sample_b5_data_wide <- mutate(sample_b5_data_wide,
    agreeableness_t2     = agreeableness_t1 + rnorm(100, .5, .2),
    conscientiousness_t2 = conscientiousness_t1 + rnorm(100, .5, .2),
    neuroticism_t2       = neuroticism_t1 + rnorm(100, .5, .2),
    extraversion_t2      = extraversion_t1 + rnorm(100, .5, .2),
    openness_t2          = openness_t1 + rnorm(100, .5, .2),
    agreeableness_t3     = agreeableness_t2 + rnorm(100, .5, .2),
    conscientiousness_t3 = conscientiousness_t2 + rnorm(100, .5, .2),
    neuroticism_t3       = neuroticism_t2 + rnorm(100, .5, .2),
    extraversion_t3      = extraversion_t2 + rnorm(100, .5, .2),
    openness_t3          = openness_t2 + rnorm(100, .5, .2),
    agreeableness_t4     = agreeableness_t3 + rnorm(100, .5, .2),
    conscientiousness_t4 = conscientiousness_t3 + rnorm(100, .5, .2),
    neuroticism_t4       = neuroticism_t3 + rnorm(100, .5, .2),
    extraversion_t4      = extraversion_t3 + rnorm(100, .5, .2),
    openness_t4          = openness_t3 + rnorm(100, .5, .2)
  )
sample_b5_data_wide
str(sample_b5_data_wide)
```

As you can see in the above, we have a row for each participant, and a column corresponding to each Big 5 score at each time point. For example, column 2 contains each participant's score on Agreeableness at time 1, column 7 contains each participant's score on Agreeableness at time 2, etc.

This data is in a *wide* format. It's also in basically the widest format it could be in for any reasonable purpose; the only way to make it wider would be to have a single row, and a column for each participant X Big 5 score X time point.

What would make this data *long*? There are two dimensions that we could lengthen the data on, but the more common one you might see is time. That is, we'd have a row for each participant X time point combination, like the following:
```{r example of a longer dataset, echo = FALSE}
sample_b5_data_long <- sample_b5_data_wide %>%
  gather(variable, score, -pid) %>%
  separate(variable, c("Trait", "time")) %>%
  spread(Trait, score)

sample_b5_data_long
```

So we now have a row for each participant at each time point, and a column for each of the Big 5. We could also make it a little longer, by making each row correspond to a score on each Big Five trait for each participant at each time point, like so:

```{r example of an even longer dataset}
sample_b5_data_long %>%
  gather(trait, score, agreeableness:openness)
```

##Piping syntax

We'll cover how to reshape

* Manipulating
    * Wide v Long data as intro
    * piping syntax (incl. when to use/not use)
    * reshaping - gather/melt & spread/dcast (https://www.r-bloggers.com/how-to-reshape-data-in-r-tidyr-vs-reshape2/)
    * reordering (incl. reordering factor levels, talking abt factors)
    * separate & colsplit
    * combining dataframes (if this makes sense to do/there's time to do it) (see relational data in r4ds)

* Annoyances
    * dealing with `NaN`s
    * typing your data (mainly to cover factors, ordered v. unordered)

# Resources

* R Data Import/Export Manual: https://cran.r-project.org/doc/manuals/R-data.pdf
* http://zoonek2.free.fr/UNIX/48_R/02.html#6
* https://www.statmethods.net/interface/io.html
* http://adv-r.had.co.nz/Subsetting.html#applications
* https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf

```{r, echo=FALSE}
# delete files to keep repo clean
file.remove("cant_forget.butiwantto")
file.remove("cant_forget.RData")
file.remove("cant_forget.rds")
file.remove("put-plots-here.pdf")
file.remove("save-everything-here.txt")
```

